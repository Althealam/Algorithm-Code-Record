# 分析：遇到两个维度需要考虑的时候，先去考虑一个维度，再去考虑另外一个维度
# Eg：[7,0][4,4][7,1][5,0][6,1][5,2] h为身高，k为数量
# 1. k维度：当k相同的时候，按照h来排（h从小到大，k从小到大排序） [5,0][7,0][6,1][7,1][5,2][4,4]
# 2. h维度：当h相同时，按照k来排（h从大到小排序，k从小到大） [7,0][7,1][6,1][5,0][5,2][4,4]（按照身高从大到小排序）
# 首先，将people按照h维度从大到小排序
# 其次，从k维度开始插入操作

# 为什么身高要从高到矮来排序：
# 如果我们从高到矮来处理，能够更容易地放置高的人，因为对于较高的人，前面已经有较高的人或者空位来满足他们的 k 值。
# 处理身高较高的人时，我们已经能确保身高较低的人仍然能够在后续插入操作中满足他们的 k 值要求。

# 为什么h相同的时候，k要从小到大排序：
# 对于 k 值较小的人，他们的前面已经可以容纳更多的人。
# 如果我们先插入 k 值大的（需要更少空位的人），可能会妨碍后续需要更多空位的人。
# 按照 k 值从小到大排序，可以确保在插入时，每个人已经在满足自己前面人数条件的位置上。

# 时间复杂度：
# 1. 排序操作：sort()的时间复杂度为O(nlogn)
# 2. 插入操作：O(n^2)
# （1）insert方法在最坏情况下的时间复杂度为O(n)
# （2）insert被调用了n次
# 总体时间复杂度：O(n^2)

# 空间复杂度：
# 1. 输入的people列表和输出的que列表都需要存储n个元素，因此它们各自占据O(n)个空间
# 2. 排序操作需要额外的空间来存储排序结果，空间复杂度为O(n)（Python的排序是原地排序，但是在排序过程中仍然需要额外的辅助空间来存放数据）
# 总体空间复杂度：O(n)
class Solution(object):
    def reconstructQueue(self, people):
        """
        :type people: List[List[int]]
        :rtype: List[List[int]]
        """
        # 按照身高从大到小排序，确定第一个维度
        # lambda返回的是一个元组：当-x[0]（维度h）相同的时候，根据x[1]（维度k）从小到大排序
        # 1. -x[0]：按照第一个元素的降序排序（h：从大到小）
        # 2. x[1]：按照第二个元素的升序排序（k：从小到大）
        people.sort(key=lambda x: (-x[0],x[1]))
        que=[] # 定义一个存放结果的数组

        # 根据每个元素的第二个维度k，贪心算法，进行插入
        # people已经排序过了：同一高度h时k值小的排在前面
        for p in people:
            # p[1]代表的是k
            # p[0]代表的是h
            que.insert(p[1],p) # p[1]是要插入的位置，p是待插入的元素
        return que

people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
# 按照身高从大到小排序后：[[7,0],[7,1],[6,1],[5,2],[5,0],[4,4]]
solution=Solution()
result=solution.reconstructQueue(people)

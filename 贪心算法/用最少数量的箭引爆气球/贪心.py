# 思路：重叠的气球尽量在一起（注意这里的气球是二维空间的）
# 分析：
# 先考虑i与i-1的气球：
# 1. 【不重叠的情况】i的左边界>i-1的右边界：i与i-1这两个气球不相邻，需要多增加一个弓箭
# 2. 【重叠的情况】i的左边界<=i-1的右边界：i与i-1这两个气球重叠，可以用一个弓箭
# 再考虑i与i+1的气球：
# 1. 【i与i-1的气球重叠】
# （1）更新气球i的边右界，让右边界为i与i-1的右边界的最小值（否则射弓箭的时候，只能射到i+1与i，不能射到i-1）
#       如果更新了气球的边界后，i+1的气球的左边界>更新的气球的右边界：需要多增加一个弓箭
#       如果更新了气球的边界后，i+1的气球的左边界<=更新的气球的右边界：可以用一个弓箭

# 时间复杂度：
# 1. 排序：sort需要根据气球的左边界对气球进行排序，O(nlogn)
# 2. 遍历气球：O(n)，每个气球会进行常数时间的比较和更新操作
# 总的时间复杂度：O(nlogn)
# 空间复杂度：
# 1. 输入数组points：point数组是输入数据，数组的大小为n
# 2. 常数空间：result，O(1)
# 总的空间复杂度：O(n)
class Solution(object):
    def findMinArrowShots(self, points):
        """
        :type points: List[List[int]]
        :rtype: int
        """
        if len(points)==0:
            return 0
        points.sort(key=lambda x: x[0]) # x[0]为左边界，按照左边界来排序
        result=1 # 需要的弓箭数量初始化为1
        for i in range(1,len(points)): # 因为需要考虑i-1，因此i初始化为1
        # 1. i的左边界>i-1的右边界：i与i-1两个气球不重叠
            if points[i][0]>points[i-1][1]: 
                result+=1
        # 2. i的左边界<=i-1的右边界：i与i-1两个气球重叠（相邻的气球也是可以用一个弓箭的）
            else: 
                points[i][1]=min(points[i-1][1],points[i][1]) # 更新气球i的右边界，继续对比i与i+1两个气球（这时候不用特别去遍历i与i+1，进入下一个循环即可）
        return result
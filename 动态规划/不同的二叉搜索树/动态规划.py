# 分析：
# n为3的二叉搜索树的数量=头节点为2的二叉搜索树的数量+头节点为1的二叉搜索树的数量+头节点为3的二叉搜索树的数量
# 1. 头节点为1的二叉搜索树的数量=左子树0节点x右子树2节点
# 2. 头节点为2的二叉搜索树的数量=左子树1节点x右子树1节点
# 3. 头节点为3的二叉搜索树的数量=左子树2节点x右子树0节点
# dp[3]=dp[0]xdp[2]+dp[2]xdp[1]+dp[2]xdp[0]

# 动态规划五部曲
# 1. dp[i]：输入为i，得到dp[i]种不同的二叉搜索树
# 2. 递归公式：
# 输入i=3
# （1）以1为头节点，左子树为0个节点，右子树有2个节点（3-1）
# （2）以2为头节点，左子树有1个节点，右子树有1个节点（3-2）
# （3）以3为头节点，左子树有2个节点，右子树有0个节点（3-3）
# （4）以j为头节点，左子树有j-1个头节点，有i-j个节点
# 递推公式：对不同的i进行遍历，dp[i]+=dp[j-1]xdp[i-j]
# 3. 初始化：dp[0]=1（空二叉树也是一种二叉搜索树），dp[1]=1，dp[2]=2
# 4. 遍历顺序：从左到右

# 时间复杂度：O(n^2)
# 空间复杂度：O(n)

class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        G=[0]*(n+1)
        G[0],G[1]=1,1

        for i in range(2,n+1):
            for j in range(1,i+1):
                G[i]+=G[j-1]*G[i-j]
        return G[n]
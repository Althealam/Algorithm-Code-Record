# 分析：
# 【0-1背包问题】的目标是选择一些物品，使得它们的总重量不超过背包容量，同时最大化它们的总价值
# 【子集和问题】则是寻找一个子集，其总和是否等于目标值。在这个问题中，目标值是数组元素和的一半
# 这道题中的目标值就是背包容量，子集就是物品

# 核心：给定一个正整数数组，判断是否可以将数组分割成两个字集，使得两个字集的元素和相等

# 本题的背包问题相当于如下要求：
# 1. 背包的体积为sum/2
# 2. 背包要放入的商品（集合里的元素）重量为元素的数值，价值也为元素的数值
# 3. 背包如果正好装满，表示找到了总和为sum/2的子集
# 4. 背包中每一个元素都是不可重复放入的

# 动态规划五部曲：
# 1. dp数组：dp[j]表示背包容量为j，放入物品后背包的最大价值为dp[j]（在本题中，相当于对于给定的数组nums，dp[j]表示是否可以通过选择数组中的一些元素，达到和为j）
# 2. 递推公式：dp[j]=max(dp[j],dp[j-nums[i]]+nums[i])
# 原本的递推公式：dp[j]=max(dp[j],dp[j-weight[i]]+value[i])，但是本题中的weight[i]=value[i]=nums[i]
# 3. 初始化：
# （1）如果题目给的价值都是正整数，那么非0下标初始化为0即可
# （2）如果题目给的价值有负数，那么非0下标就要初始化为负无穷
# 4. 确定遍历顺序：如果使用一维dp数组，那么物品遍历的for循环放在最外层，背包的for循环放在最内层，并且内层for循环倒序遍历

class Solution(object):
    def canPartition(self, nums):
        """
        :type nums: List[int]
        :rtype: bool
        """
        _sum=0
        dp=[0]*10001 

        # 求数组内的总和
        _sum=sum(nums)

        # 如果_sum不是偶数的话，那一定没办法分割数组
        if _sum%2==1:
            return False

        # 这个相当于是背包的总容量
        target=_sum//2

        # 开始0-1背包
        for num in nums: # 遍历物品
            for j in range(target,num-1,-1): # 遍历背包，每一个元素一定是不可重复放入，所以从大到小遍历
                dp[j]=max(dp[j],dp[j-num]+num)
                # 参考0-1背包问题（二）部分，这里是滚动数组，并且weight[i]=value[i]=num

        # 集合中的元素正好可以凑成总和target
        if dp[target]==target:
            return True
        return False



        
# 方法：动态规划法
# 分析：其实这道题就是一个斐波那契数列
# 1. 一阶：一种方法
# 2. 二阶：两种方法
# 3. 三阶：三种方法（三阶的方法数就是一阶的方法数+二阶的方法数）
# 4. 四阶：五种方法（四阶的方法数就是二阶的方法数+三阶的方法数）
# 为什么是前面两阶的方法数之和：以四阶为例，四阶可以由二阶迈两步，也可以由三阶迈一步

# 动态规划五部曲：
# 1. dp[i]的含义：dp[i]指的是达到第i阶有dp[i]种方法
# 2. 确定递推公式：dp[i]=dp[i-1]+dp[i-2]（一定要先确定递推公式再写初始化）
# 3. 初始化：由于n是正整数，所以不会出现dp[0]   dp[1]=1, dp[2]=2
# 4. 确定遍历顺序：从前向后，因为dp[i]依赖于前面两个状态
# 5. 打印dp数组（debug）

# 时间复杂度：O(n)
# 1. 初始化dp数组：O(n)
# 2. 动态规划填充dp数组：O(n)
# 空间复杂度：O(n)
# 1. dp数组：O(n)

class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        
        # 初始化
        # 虽然我们没有初始化dp[0]，但是实际上dp是一个数组，它的下标是从0开始的，而我们需要存储从dp[0]到dp[n]的所有值
        dp=[0]*(n+1) # 这里为什么是n+1，而不是n：这是为了让我们能够访问到dp[n]，否则当我们访问dp[n]的时候会出现越界
        
        dp[1]=1
        dp[2]=2

        for i in range(3,n+1):
            dp[i]=dp[i-1]+dp[i-2]

        return dp[n]
        
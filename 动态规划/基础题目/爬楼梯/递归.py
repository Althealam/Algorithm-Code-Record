# 方法：递归法（精简版）
# 分析：其实这道题就是一个斐波那契数列
# 1. 一阶：一种方法
# 2. 二阶：两种方法
# 3. 三阶：三种方法（三阶的方法数就是一阶的方法数+二阶的方法数）
# 4. 四阶：五种方法（四阶的方法数就是二阶的方法数+三阶的方法数）
# 为什么是前面两阶的方法数之和：以四阶为例，四阶可以由二阶迈两步，也可以由三阶迈一步

# 动态规划五部曲：
# 1. dp[i]的含义：dp[i]指的是达到第i阶有dp[i]种方法
# 2. 确定递推公式：dp[i]=dp[i-1]+dp[i-2]（一定要先确定递推公式再写初始化）
# 3. 初始化：由于n是正整数，所以不会出现dp[0]   dp[1]=1, dp[2]=2
# 4. 确定遍历顺序：从前向后，因为dp[i]依赖于前面两个状态
# 5. 打印dp数组（debug）

# 时间复杂度：O(2^n)
# 1. 递归树结构：高度为O(n)
# 2. 重复计算：O(2^n)
# 空间复杂度：O(n)
# 1. 递归栈：递归每次都会生活从呢个一个递归栈，栈的深度是由递归的最大深度决定的
class Solution(object):
    def climbStairs(self, n):
        """
        :type n: int
        :rtype: int
        """
        if n<=2:
            return n
        return self.climbStairs(n-1)+self.climbStairs(n-2)
        
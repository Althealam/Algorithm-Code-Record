# 1. dp数组以及下标的含义：dp[i]表示1到i为节点组成的二叉搜索树的个数为dp[i]
# 2. 递推公式：dp[i]+=dp[j-1]*dp[i-j]
# dp[3]=元素1为头节点的搜索树的数量+元素2为头节点的搜索树的数量+元素3为头结点的搜索树的数量
# （1）元素1为头节点的搜索树的数量=右子树有2个元素的搜索树的数量*左子树有0个元素的搜索树的数量
# （2）元素2为头节点的搜索树的数量=右子树有1个元素的搜索树的数量*左子树有1个元素的搜索树的数量
# （3）元素3为头节点的搜索树的数量=右子树有0个元素的搜素树的数量*左子树有2个元素的搜索树的数量
# 因此dp[3]=dp[2]*dp[0]+dp[1]*dp[1]*dp[0]*dp[2]
# 3. 初始化：dp[0]=1
# 4. 遍历顺序：由递推公式可以知道节点数为i的状态是依靠i之前节点数的状态，因此是从左到右

# 注意，当n为节点数并且当i为根节点的时候，其左子树的节点个数为i-1，右子树的节点个数为n-''i（可以考虑二叉搜索树的构造，如果n是一个数组的话，i为根节点的话，只有小于i的在左子树，大于i的在右子树，那么左子树的节点数为i''-1，右子树的节点数为n-i，因为总的节点数为(i-1)+1+(n-i)=n）
# 以i为根节点的二叉搜索树的个数：f(i)=G(i-1)*G(n-i)
# n个节点的二叉搜索树的个数：G(n)=f(1)+f(2)+...+f(n)（这里的G就是dp数组）

# 时间复杂度：O(n^2)
# 空间复杂度：O(n)

class Solution(object):
    def numTrees(self, n):
        """
        :type n: int
        :rtype: int
        """
        dp=[0]*(n+1)
        dp[0]=1
        for i in range(1, n+1): # i个节点的二叉排序树的个数
            for j in range(1,i+1): # 以j为节点的二叉排序树的个数
                dp[i]+=dp[j-1]*dp[i-j]
        return dp[n]
# 方法：暴力法
# 思路：一个for循环获取子串的终止位置，然后再次嵌套一个for循环判断子串是否能重复构成字符串
# 时间复杂度：O(n^2)
# 为什么只需要判断子串的终止位置？
# 答案：子串的第一个字母一定是字符串的开头字母，否则没有讨论的必要
class Solution(object):
    def repeatedSubstringPattern(self, s):
        """
        :type s: str
        :rtype: bool
        """
        n=len(s)
        if n<=1: # 如果n<=1，就不可能由重复的子串构成
            return False
        
        substr="" # 代表获得的子串
        for i in range(1,n//2+1):
            # 遍历所有可能的子串长度（从1到字符串长度的一半，并且是包含字符串长度的一半）
            # 这是因为如果子串长度超过一半，那么重复次数必须为2或者更少，这在逻辑上是不可能的
            # 因为重复两次就超过了整个字符串的长度
            if n%i==0: # 检查字符串长度是否可以被子串长度整除，如果可以，说明有可能通过重复子串来构造原字符串
                substr=s[:i] # 构建子串
                if substr*(n//i)==s: # 检查通过重复子串substr若干次（次数为n//i）是否能够构造出原来的字符串s
                # 如果可以的话，说明原字符串是可以通过重复子串来构造的
                    return True
        
        return False
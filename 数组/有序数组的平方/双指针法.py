# 方法三：双指针法
# 时间复杂度：O(n)
# 双指针法的时间复杂度是O(n)，因为我们只需要遍历一次数组，对于每个元素，我们只做一次平放操作和一次比较操作，这些操作的时间复杂度都是O(1)
# 循环中的left+=1和right-=1的操作的时间复杂度也是O(1)

# 空间复杂度：O(n)
# 创建了一个长度与输入数组相同的结果数组result
# 除了输入数组和输出数组之外，我们只使用了常数级别的额外空间（左指针left和右指针right）

# 思路：
# 1. 使用双指针：由于数组已经是非递减排序，因此可以从数组的两端开始考虑。假设左指针left指向数组的起始位置，右指针right指向数组的末尾
# 2. 选择较大平方：比较两个指针所指向的数的平方，选择平方较大的那个数放到结果数组的末尾。
# 3. 维护非递减顺序：对于任何两个平方后的数，如果它们在原数组中是相邻的，那么它们的平方也满足非递减顺序。
# 4. 迭代直至中间：继续这个过程，直到左指针和右指针相遇或者交错，这时候结果数组已经被正确填充
class Solution(object):
    def sortedSquares(self, nums):
        """
        :type nums: List[int]
        :rtype: List[int]
        """
        left=0 # 左指针
        right=len(nums)-1 # 右指针
        result=[0]*len(nums) # 存放结果
        # 从后往前填充数组
        for i in range(len(nums)-1,-1,-1):
            # len(nums)-1：序列的起始值
            # -1：序列的结束值，但是不包括这个值的本身
            # -1：步长，表示每次递减的量
            # 比较左右指针的平方，将较大的结果放到结果数组
            if nums[left]**2>nums[right]**2:
                result[i]=nums[left]**2
                left+=1
            else:
                result[i]=nums[right]**2
                right-=1
        return result
                
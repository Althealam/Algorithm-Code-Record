# 方法一：仅使用栈
# 思路：如果遇到左括号，就让右括号进栈；遇到左花括号，就要右花括号进栈
# 最后开始遍历栈，如果遇到右边的括号就弹出
# 如果字符串的长度为奇数，那么一定有不匹配的，直接返回false
# 分析：
# 1. 第一种情况：字符串里左方向的括号多余了，所以不匹配
# 2. 第二种情况：括号没有多余，但是括号的类型没有匹配上
# 3. 第三种情况：字符串里右方向的括号多余了，所以不匹配
# 结果：
# 1. 第一种情况：已经遍历完了字符串，但是栈不为空，说明有相应的左括号没有右括号来匹配
# 2. 第二种情况：遍历字符串匹配的过程中，发现栈里没有要匹配的字符
# 3. 第三种情况：遍历字符串匹配的过程中，栈已经为空了，没有匹配的字符了，说明右括号没有找到对应的左括号
# 左右括号匹配的情况：字符串遍历完后，栈是空的

# 时间复杂度：O(n)
# 1. 遍历字符串中的每个字符：O(n)
# 2. 栈操作：O(1)
# 空间复杂度：O(n)
# 栈的最大大小取决于字符串中括号的数量，在最坏的情况下，字符串可能只会含有左括号，此时栈的大小将与字符串的大小相同


class Solution(object):
    def isValid(self, s):
        """
        :type s: str
        :rtype: bool
        """
        stack=[]
        for item in s:
            if item=='(':
                stack.append(')')
            elif item=='{':
                stack.append('}')
            elif item=='[':
                stack.append(']')
            elif not stack or stack[-1]!=item:
                # 如果stack为1，那么not stack为0
                # 如果stack为0，那么not stack为1
                # 因此如果not stack为1的时候，就会返回false
                # 检查栈是否为空：如果栈为空，意味着没有开括号可以与当前的闭括号匹配，返回false
                # 检查栈顶的元素（最后一个压入栈的元素）是否与当前的闭括号相匹配，如果不匹配就返回false
                return False
            else:
                stack.pop()
        
        return True if not stack else False